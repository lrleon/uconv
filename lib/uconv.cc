/*
   _   _  ___ ___  _ ____   __
  | | | |/ __/ _ \| '_ \ \ / /  C++ Physical magnitudes and units conversion
  | |_| | (_| (_) | | | \ V /   Version 1.0
   \__,_|\___\___/|_| |_|\_/    https://github.com/lrleon/uconv

  This file is part of uconv library

  Copyright (c) 2018     Ixhel Mejias
                         Alberto Valderrama
                         Leandro Rabindranath Leon

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <https://www.gnu.org/licenses/>.
*/# include <iostream>

# include <ah-stl-utils.H>

# include <uconv.H>
# include <uconv-list.H>

# include <nlohmann/json.hpp> 

using json = nlohmann::json;

static void init_unit_converters();

// the following data is declared in units.H
UnitItemTable * PhysicalQuantity::tbl = nullptr;

UnitItemTable * Unit::tbl = nullptr;

DynSetTree<const Unit *> * Unit::unit_tbl = nullptr;

static size_t fst_unit_pair_hash
(const pair<pair<const Unit*, const Unit*>, Unit_Convert_Fct_Ptr> & p)
{
  return dft_hash_fct(p.first);
}

static size_t snd_unit_pair_hash
(const pair<pair<const Unit*, const Unit*>, Unit_Convert_Fct_Ptr> & p)
{
  return snd_hash_fct(p.first);
}

UnitMap * __unit_map = nullptr;
CompoundUnitTbl * __compound_unit_tbl = nullptr;

const PhysicalQuantity PhysicalQuantity::null_physical_quantity;

const Unit Unit::null_unit;

const double Unit::Invalid_Value = numeric_limits<double>::max();

const VtlQuantity VtlQuantity::null_quantity;

/* The goal of this function is to assure that the tables required by
   the units system are adequately initialized. 

   The technique consists in instantiating the required tables as
   static variables of this constructor. In this way we assure that
   tables are instantiated exactly once time. These static variables
   use the default constructor. Then, on each table the real
   constructor is called through the placement new operator
*/
UnitsInstancer::UnitsInstancer()
{
  static size_t count = 0;
  if (count++ > 0)
    return;
  
  static UnitItemTable physicalquantity_tbl;
  static UnitItemTable unit_tbl;
  static DynSetTree<const Unit *> unit_unit_tbl;

  PhysicalQuantity::tbl = &physicalquantity_tbl;
  Unit::tbl = &unit_tbl;
  Unit::unit_tbl = &unit_unit_tbl;

  static UnitMap __unit_map(3500, fst_unit_pair_hash, snd_unit_pair_hash);
  ::__unit_map = &__unit_map;

  static CompoundUnitTbl __compound_unit_tbl;
  ::__compound_unit_tbl = &__compound_unit_tbl;

  new ((void*) &PhysicalQuantity::null_physical_quantity)
    PhysicalQuantity("NullPhysicalQuantity", "NullPQ",
		     "Null" "Null Physical Quantity");

  new ((void*) &Unit::null_unit) Unit("NullUnit", "Null Unit", "Null unit", "Null",
				      PhysicalQuantity::null_physical_quantity,
				      numeric_limits<double>::min(),
				      numeric_limits<double>::max());

  new ((void*) &VtlQuantity::null_quantity)
    VtlQuantity(Unit::null_unit, numeric_limits<double>::max());

  init_unit_converters(); // this routine is generated by extract-cv
			  // script and concatenated to this file
}

bool conversion_exist(const char * src_symbol, const char * tgt_symbol)
{
  return exist_conversion(src_symbol, tgt_symbol);
}

double unit_convert(const char * src_symbol, const char * tgt_symbol,
		    double val)
{
  return unit_convert_symbol_to_symbol(src_symbol, val, tgt_symbol);
}

static json to_json(const Unit * unit_ptr)
{
  json j;
  j["name"] = unit_ptr->name;
  j["description"] = unit_ptr->description;
  j["symbol"] = unit_ptr->symbol;
  j["latex_symbol"] = unit_ptr->latex_symbol;
  j["minimum_value"] = unit_ptr->min_val;
  j["maximum_value"] = unit_ptr->max_val;
  j["epsilon"] = unit_ptr->get_epsilon();
  return j;
}

static json to_json(const PhysicalQuantity * const pq)
{
  json j;
  j["name"] = pq->name;
  j["description"] = pq->description;
  j["symbol"] = pq->symbol;
  j["latex_symbol"] = pq->latex_symbol;
  j["units"] =
    to_vector(pq->units().maps<json>([] (auto p) { return to_json(p); }));
  
  return j;
}

string units_json()
{
  json j;
  j["uconv_physical_quantities"] =
    to_vector(PhysicalQuantity::quantities().maps<json>([] (auto p)
    { return to_json(p); }));
  return j.dump(2);
}

const UnitsInstancer & units_instance = UnitsInstancer::init();

// The following global singleton variables are generated by extract-cv script
