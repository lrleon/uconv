#!/usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'optparse'
require 'fileutils'

alephw = ENV['ALEPHW']
json = ENV['JSON']

fail 'Aleph-w environment variable has not been defined' unless alephw
fail 'Niels Lohmann json library environment variable has not been defined' unless json

options = {}
options_parser = OptionParser.new do |opts|

  opts.on('-U uconv-list-file', '--units-path uconv-list-file-H ',
          'full path to uconv-list header') do |path|
    options[:units_file] = path
  end

  opts.on('-H path-to-uconv-header', '--path-uconv path-to-uconv-header',
          'full path to uconv.H file') do |path|
    options[:uconv_path] = path
  end

  opts.on('-c compiler-name', '--compiler compiler-name',
          'compiler name') do |compiler|
    options[:compiler] = compiler
  end

  opts.on('-l library-name', '--library library-name',
          'library name') do |libname|
    options[:libname] = libname
  end
end

options_parser.parse!

units_file = options[:units_file]
uconv_path = options[:uconv_path]
compiler = options[:compiler] ? options[:compiler] : 'c++'
libname = options[:libname] ? options[:libname] : 'libuconv.a'

fail 'uconv-list-file has not been specified' unless units_file
fail "#{units_file}  does not exist" unless File.exists?(units_file)

ucontent = %Q(
# include <iostream>

# include <ah-stl-utils.H>

# include <uconv.H>
# include "#{units_file}"

# include <nlohmann/json.hpp> 

using json = nlohmann::json;

static void init_unit_converters();

// the following data is declared in units.H
UnitItemTable * PhysicalQuantity::tbl = nullptr;

UnitItemTable * Unit::tbl = nullptr;

DynSetTree<const Unit *> * Unit::unit_tbl = nullptr;

static size_t fst_unit_pair_hash
(const pair<pair<const Unit*, const Unit*>, Unit_Convert_Fct_Ptr> & p)
{
  return dft_hash_fct(p.first);
}

static size_t snd_unit_pair_hash
(const pair<pair<const Unit*, const Unit*>, Unit_Convert_Fct_Ptr> & p)
{
  return snd_hash_fct(p.first);
}

UnitMap * __unit_map = nullptr;
CompoundUnitTbl * __compound_unit_tbl = nullptr;

const PhysicalQuantity PhysicalQuantity::null_physical_quantity;

const Unit Unit::null_unit;

const double Unit::Invalid_Value = numeric_limits<double>::max();

const VtlQuantity VtlQuantity::null_quantity;

/* The goal of this function is to assure that the tables required by
   the units system are adequately initialized. 

   The technique consists in instantiating the required tables as
   static variables of this constructor. In this way we assure that
   tables are instantiated exactly once time. These static variables
   use the default constructor. Then, on each table the real
   constructor is called through the placement new operator
*/
UnitsInstancer::UnitsInstancer()
{
  static size_t count = 0;
  if (count++ > 0)
    return;
  
  static UnitItemTable physicalquantity_tbl;
  static UnitItemTable unit_tbl;
  static DynSetTree<const Unit *> unit_unit_tbl;

  PhysicalQuantity::tbl = &physicalquantity_tbl;
  Unit::tbl = &unit_tbl;
  Unit::unit_tbl = &unit_unit_tbl;

  static UnitMap __unit_map(3500, fst_unit_pair_hash, snd_unit_pair_hash);
  ::__unit_map = &__unit_map;

  static CompoundUnitTbl __compound_unit_tbl;
  ::__compound_unit_tbl = &__compound_unit_tbl;

  new ((void*) &PhysicalQuantity::null_physical_quantity)
    PhysicalQuantity("NullPhysicalQuantity", "NullPQ",
		     "Null" "Null Physical Quantity");

  new ((void*) &Unit::null_unit) Unit("NullUnit", "Null Unit", "Null unit", "Null",
				      PhysicalQuantity::null_physical_quantity,
				      numeric_limits<double>::min(),
				      numeric_limits<double>::max());

  new ((void*) &VtlQuantity::null_quantity)
    VtlQuantity(Unit::null_unit, numeric_limits<double>::max());

  init_unit_converters(); // this routine is generated by extract-cv
			  // script and concatenated to this file
}

bool conversion_exist(const char * src_symbol, const char * tgt_symbol)
{
  return exist_conversion(src_symbol, tgt_symbol);
}

double unit_convert(const char * src_symbol, const char * tgt_symbol,
		    double val)
{
  return unit_convert_symbol_to_symbol(src_symbol, val, tgt_symbol);
}

static json to_json(const Unit * unit_ptr)
{
  json j;
  j["name"] = unit_ptr->name;
  j["description"] = unit_ptr->description;
  j["symbol"] = unit_ptr->symbol;
  j["latex_symbol"] = unit_ptr->latex_symbol;
  j["minimum_value"] = unit_ptr->min_val;
  j["maximum_value"] = unit_ptr->max_val;
  j["epsilon"] = unit_ptr->get_epsilon();
  return j;
}

static json to_json(const PhysicalQuantity * const pq)
{
  json j;
  j["name"] = pq->name;
  j["description"] = pq->description;
  j["symbol"] = pq->symbol;
  j["latex_symbol"] = pq->latex_symbol;
  j["units"] =
    to_vector(pq->units().maps<json>([] (auto p) { return to_json(p); }));
  
  return j;
}

string units_json()
{
  json j;
  j["uconv_physical_quantities"] =
    to_vector(PhysicalQuantity::quantities().maps<json>([] (auto p)
    { return to_json(p); }));
  return j.dump(2);
}

const UnitsInstancer & units_instance = UnitsInstancer::init();

// The following global singleton variables are generated by extract-cv script
)

def write_to_file(name, content)
  file = File.new(name, 'w')
  file.write content
  file.close
end

file = ucontent

write_to_file 'uconv_tmp.cc', ucontent

includes = "-I. -I#{uconv_path} -I#{alephw} -I#{json}/include"
flags = "-Wall -Wextra -Wcast-align -Wno-sign-compare -Wno-write-strings "\
        "-Wno-parentheses -O2 -DNDEBUG -std=c++14"

symbols_file = `cpp #{includes} #{flags} uconv_tmp.cc uconv_tmp.cxx`
write_to_file 'tmp', symbols_file

lines = `grep "UnitConverter.*__uc__" uconv_tmp.cxx`.split("\n")

file += "\n"\
        "static void init_unit_converters()\n"\
        "{\n"
lines.each do |line|
  r = line.match(/UnitConverter<.*,.*> __uc__.*__to__[^;.]*;/)
  file += "  #{r[0]}\n"\
          "\n"
end
file += "}"

write_to_file 'libuconv.cc', file

compiler_cmd = "#{compiler} #{includes} #{flags} -c -o libuconv.o libuconv.cc"

puts compiler_cmd

status = %x( #{compiler_cmd} )
status = %x(ar clq #{libname} libuconv.o) if status
status = %x(ranlib #{libname}) if status

File.delete 'uconv_tmp.cc'
File.delete 'uconv_tmp.cxx'
File.delete 'libuconv.o'
File.delete 'libuconv.cc'


