#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'erb'
require 'fileutils'

# --- Data Structures ---

class Element
  attr_accessor :source_file
end

class PhysicalQuantity < Element
  attr_accessor :name, :symbol, :latex, :description

  def initialize(name)
    @name = name
  end
end

class Unit < Element
  attr_accessor :name, :symbol, :latex, :description, :quantity, :min, :max

  def initialize(name)
    @name = name
    @min = 0.0
    @max = 0.0
  end
end

class Conversion < Element
  attr_accessor :from, :to, :formula

  def initialize(from, to, &block)
    @from = from
    @to = to
    @formula = block
  end
end

# --- DSL Context ---

class DSL
  attr_reader :quantities, :units, :conversions

  def initialize(root_dir)
    @quantities = []
    @units = []
    @conversions = []
    @current_file = "unknown"
    @root_dir = root_dir
  end

  def import(file)
    # Resolve file path relative to project root
    full_path = File.expand_path(file, @root_dir)

    prev_file = @current_file
    @current_file = File.basename(file, ".rb")

    begin
      content = File.read(full_path)
    rescue Errno::ENOENT
      # Fallback: try relative to current working directory or just as is
      content = File.read(file)
    end

    instance_eval(content, full_path)
    @current_file = prev_file
  end

  def physical_quantity(name, &block)
    pq = PhysicalQuantity.new(name.to_s)
    pq.source_file = @current_file
    Context.new(pq).instance_eval(&block)
    @quantities << pq
  end

  def unit(name, &block)
    u = Unit.new(name.to_s)
    u.source_file = @current_file
    Context.new(u).instance_eval(&block)
    # Validation deferred or simple check
    @units << u
  end

  def conversion(from, to, &block)
    c = Conversion.new(from.to_s, to.to_s, &block)
    c.source_file = @current_file
    @conversions << c
  end

  private

  class Context
    def initialize(target)
      @target = target
    end

    def symbol(val) @target.symbol = val; end
    def latex(val) @target.latex = val; end
    def description(val) @target.description = val; end

    # For Unit
    def quantity(val) @target.quantity = val.to_s; end
    def range(val)
      @target.min = val.begin
      @target.max = val.end
    end
  end
end

# --- C++ Generation Template ---

TEMPLATE = <<~CPP
/*
   AUTOMATICALLY GENERATED FILE - DO NOT EDIT
   Generated by bin/gen-units from <%= source_file %>.rb
*/

#ifndef <%= guard_name %>
#define <%= guard_name %>

#include "uconv.H"

// --- Physical Quantities ---

<% quantities.each do |pq| %>
struct <%= pq.name %> : public PhysicalQuantity {
    static const <%= pq.name %>& get_instance() {
        static <%= pq.name %> instance;
        return instance;
    }
private:
    <%= pq.name %>() : PhysicalQuantity("<%= pq.name %>", "<%= pq.symbol %>", "<%= pq.latex %>", R"DESC(<%= pq.description %>)DESC") {}
public:
    <%= pq.name %>(const <%= pq.name %>&) = delete;
    void operator=(const <%= pq.name %>&) = delete;
};
<% end %>

// --- Units ---

<% units.each do |u| %>
struct <%= u.name %> : public Unit {
    static const <%= u.name %>& get_instance() {
        static <%= u.name %> instance;
        return instance;
    }
private:
    <%= u.name %>() : Unit("<%= u.name %>", "<%= u.symbol %>", "<%= u.latex %>", R"DESC(<%= u.description %>)DESC", <%= u.quantity %>::get_instance(), <%= u.min %>, <%= u.max %>) {}
public:
    <%= u.name %>(const <%= u.name %>&) = delete;
    void operator=(const <%= u.name %>&) = delete;
};
// Register converter for self
template <> inline double unit_convert<<%= u.name %>, <%= u.name %>>(double val) { return val; }
static UnitConverter<<%= u.name %>, <%= u.name %>> __uc__<%= u.name %>__to__<%= u.name %>;
<% end %>

// --- Conversions ---

<% conversions.each do |c| %>
// From <%= c.from %> to <%= c.to %>
template <> inline double unit_convert<<%= c.from %>, <%= c.to %>>(double V) {
    return <%= c.formula.call('V') %>;
}
// Register converter
static UnitConverter<<%= c.from %>, <%= c.to %>> __uc__<%= c.from %>__to__<%= c.to %>;
<% end %>

#endif // <%= guard_name %>
CPP

# --- Main Execution ---

if ARGV.length < 2
  puts "Usage: gen-units <dsl_file> <output_dir>"
  exit 1
end

dsl_file = ARGV[0]
output_dir = ARGV[1]

# Determine project root based on dsl_file location
# dsl_file is expected to be in lib/units.rb, so root is two levels up
project_root = File.expand_path("../..", dsl_file)

FileUtils.mkdir_p(output_dir)

dsl = DSL.new(project_root)

begin
  dsl.instance_eval(File.read(dsl_file), dsl_file)
rescue StandardError => e
  abort "Error parsing DSL: #{e.message}\n#{e.backtrace.join("\n")}"
end

# Group by source file
files = (dsl.quantities + dsl.units + dsl.conversions).map(&:source_file).uniq.reject { |f| f == "unknown" }

generated_files = []

files.each do |source_file|
  quantities = dsl.quantities.select { |e| e.source_file == source_file }
  units = dsl.units.select { |e| e.source_file == source_file }
  conversions = dsl.conversions.select { |e| e.source_file == source_file }

  guard_name = "UNITS_#{source_file.upcase}_H"

  renderer = ERB.new(TEMPLATE, trim_mode: '-')
  content = renderer.result(binding)

  filename = "#{source_file}.H"
  out_path = File.join(output_dir, filename)
  File.write(out_path, content)
  puts "Generated #{out_path}"
  generated_files << filename
end

# Generate all_units.H
all_units_content = <<~CPP
/*
   AUTOMATICALLY GENERATED FILE - DO NOT EDIT
   Includes all generated unit headers.
*/
#ifndef ALL_UNITS_H
#define ALL_UNITS_H

<% generated_files.each do |f| %>
#include "<%= f %>"
<% end %>

#endif // ALL_UNITS_H
CPP

renderer = ERB.new(all_units_content, trim_mode: '-')
File.write(File.join(output_dir, "all_units.H"), renderer.result(binding))
puts "Generated #{File.join(output_dir, "all_units.H")}"
